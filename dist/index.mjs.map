{"version":3,"sources":["../src/supabase/client.ts","../src/rpc/index.ts","../src/queries/public.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport type { Database } from '../types/database';\n\n/**\n * Valida la configurazione Supabase e ritorna URL e anonKey garantiti non undefined.\n * Lancia errori chiari se mancano.\n */\nexport function assertSupabaseConfig(\n  url: string | undefined,\n  anonKey: string | undefined\n): { url: string; anonKey: string } {\n  if (!url) {\n    throw new Error('Supabase URL is required. Please provide a valid URL.');\n  }\n  if (!anonKey) {\n    throw new Error('Supabase anon key is required. Please provide a valid anon key.');\n  }\n  return { url, anonKey };\n}\n\n/**\n * Configurazione per il client browser Supabase\n */\nexport type SupabaseBrowserClientConfig = {\n  url: string;\n  anonKey: string;\n  storageKey?: string;\n  enableTimeoutMs?: number;\n  detectSessionInUrl?: boolean;\n};\n\n/**\n * Crea un fetch wrapper con timeout usando AbortController\n */\nfunction createFetchWithTimeout(timeoutMs: number): typeof fetch {\n  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal,\n      });\n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Request timeout after ${timeoutMs}ms`);\n      }\n      throw error;\n    }\n  };\n}\n\n/**\n * Crea un Supabase client per browser (React web apps).\n * \n * Configurazioni predefinite:\n * - persistSession: true\n * - autoRefreshToken: true\n * - detectSessionInUrl: true (configurabile, utile per web reset/login)\n * - storage: window.localStorage se disponibile\n * - fetch timeout: 30000ms se enableTimeoutMs non specificato\n */\nexport function createSupabaseBrowserClient(\n  config: SupabaseBrowserClientConfig\n): SupabaseClient<Database> {\n  const { url, anonKey } = assertSupabaseConfig(config.url, config.anonKey);\n  \n  const storageKey = config.storageKey ?? 'sb-auth-token';\n  const detectSessionInUrl = config.detectSessionInUrl ?? true;\n  const enableTimeoutMs = config.enableTimeoutMs ?? 30000;\n\n  // Determina storage: usa window.localStorage se disponibile, altrimenti undefined\n  const storage = typeof window !== 'undefined' && window.localStorage ? window.localStorage : undefined;\n\n  // Configura fetch con timeout se necessario\n  const customFetch = enableTimeoutMs > 0 \n    ? createFetchWithTimeout(enableTimeoutMs)\n    : undefined;\n\n  return createClient<Database>(url, anonKey, {\n    auth: {\n      persistSession: true,\n      autoRefreshToken: true,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n    },\n    global: {\n      fetch: customFetch,\n    },\n  });\n}\n\n/**\n * Configurazione per il client Expo Supabase\n */\nexport type SupabaseExpoClientConfig = {\n  url: string;\n  anonKey: string;\n  storage?: {\n    getItem: (key: string) => Promise<string | null> | string | null;\n    setItem: (key: string, value: string) => Promise<void> | void;\n    removeItem: (key: string) => Promise<void> | void;\n  };\n  storageKey?: string;\n};\n\n/**\n * Crea un Supabase client per Expo/React Native.\n * \n * Configurazioni predefinite:\n * - persistSession: true\n * - autoRefreshToken: true\n * - detectSessionInUrl: false (non supportato in Expo)\n * - storage: passato dal consumer (es. expo-secure-store, AsyncStorage, ecc.)\n * \n * NOTA: Non assume localStorage. Il consumer deve passare uno storage compatibile.\n * Esempio con expo-secure-store o @react-native-async-storage/async-storage\n */\nexport function createSupabaseExpoClient(\n  config: SupabaseExpoClientConfig\n): SupabaseClient<Database> {\n  const { url, anonKey } = assertSupabaseConfig(config.url, config.anonKey);\n  \n  const storageKey = config.storageKey ?? 'sb-auth-token';\n  const storage = config.storage;\n\n  return createClient<Database>(url, anonKey, {\n    auth: {\n      persistSession: true,\n      autoRefreshToken: true,\n      detectSessionInUrl: false, // Non supportato in Expo\n      storage: storage as any, // Supabase accetta storage custom con questa interfaccia\n      storageKey,\n    },\n  });\n}\n\n","import type { SupabaseClient } from '@supabase/supabase-js';\nimport type { Database } from '../types/database';\n\n/**\n * Risultato della chiamata RPC book_lesson\n */\nexport type BookLessonResult = {\n  ok: boolean;\n  reason?: string;\n  booking_id?: string | number;\n};\n\n/**\n * Risultato della chiamata RPC cancel_booking\n */\nexport type CancelBookingResult = {\n  ok: boolean;\n  reason?: string;\n};\n\n/**\n * Parametri per bookLesson\n */\nexport type BookLessonParams = {\n  lessonId: string;\n  subscriptionId?: string;\n};\n\n/**\n * Parametri per cancelBooking\n */\nexport type CancelBookingParams = {\n  bookingId: string;\n};\n\n/**\n * Risultato della chiamata RPC book_event\n */\nexport type BookEventResult = {\n  ok: boolean;\n  reason?: string;\n  booking_id?: string | number;\n};\n\n/**\n * Risultato della chiamata RPC cancel_event_booking\n */\nexport type CancelEventBookingResult = {\n  ok: boolean;\n  reason?: string;\n};\n\n/**\n * Parametri per bookEvent\n */\nexport type BookEventParams = {\n  eventId: string;\n};\n\n/**\n * Parametri per cancelEventBooking\n */\nexport type CancelEventBookingParams = {\n  bookingId: string;\n};\n\n/**\n * Parametri per staffBookEvent\n */\nexport type StaffBookEventParams = {\n  eventId: string;\n  clientId: string;\n};\n\n/**\n * Parametri per staffCancelEventBooking\n */\nexport type StaffCancelEventBookingParams = {\n  bookingId: string;\n};\n\n/**\n * Helper per gestire errori dalle chiamate RPC\n */\nfunction handleRpcError(error: any, rpcName: string): never {\n  if (error?.message) {\n    throw new Error(`RPC ${rpcName} failed: ${error.message}`);\n  }\n  if (error?.details) {\n    throw new Error(`RPC ${rpcName} failed: ${error.details}`);\n  }\n  if (error?.hint) {\n    throw new Error(`RPC ${rpcName} failed: ${error.hint}`);\n  }\n  throw new Error(`RPC ${rpcName} failed with unknown error: ${JSON.stringify(error)}`);\n}\n\n/**\n * Wrapper tipizzato per la RPC book_lesson.\n * Prenota una lezione usando l'ID della lezione e opzionalmente l'ID della subscription.\n * \n * @param client - Il client Supabase autenticato\n * @param params - Parametri per la prenotazione\n * @returns Promise<BookLessonResult> con ok, reason opzionale, e booking_id se successo\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function bookLesson(\n  client: SupabaseClient<Database>,\n  params: BookLessonParams\n): Promise<BookLessonResult> {\n  const { lessonId, subscriptionId } = params;\n\n  const { data, error } = await client.rpc('book_lesson', {\n    p_lesson_id: lessonId,\n    p_subscription_id: subscriptionId,\n  });\n\n  if (error) {\n    handleRpcError(error, 'book_lesson');\n  }\n\n  // Assumiamo che la RPC ritorni un oggetto con ok, reason?, booking_id?\n  // Se ritorna un array o altro formato, il consumer dovrà adattare i types\n  return data as BookLessonResult;\n}\n\n/**\n * Wrapper tipizzato per la RPC cancel_booking.\n * Cancella una prenotazione usando l'ID della prenotazione.\n * \n * @param client - Il client Supabase autenticato\n * @param params - Parametri per la cancellazione\n * @returns Promise<CancelBookingResult> con ok e reason opzionale\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function cancelBooking(\n  client: SupabaseClient<Database>,\n  params: CancelBookingParams\n): Promise<CancelBookingResult> {\n  const { bookingId } = params;\n\n  // Validazione: assicuriamoci che bookingId sia una stringa non vuota\n  if (!bookingId || typeof bookingId !== 'string') {\n    throw new Error('cancelBooking: bookingId must be a non-empty string');\n  }\n\n  // Chiamata RPC con tipo esplicito dal Database\n  const { data, error } = await client.rpc('cancel_booking', {\n    p_booking_id: bookingId,\n  } as Database['public']['Functions']['cancel_booking']['Args']);\n\n  if (error) {\n    handleRpcError(error, 'cancel_booking');\n  }\n\n  // Assumiamo che la RPC ritorni un oggetto con ok, reason?\n  return data as CancelBookingResult;\n}\n\n/**\n * Wrapper tipizzato per la RPC book_event.\n * Prenota un evento usando l'ID dell'evento.\n * \n * @param client - Il client Supabase autenticato\n * @param params - Parametri per la prenotazione\n * @returns Promise<BookEventResult> con ok, reason opzionale, e booking_id se successo\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function bookEvent(\n  client: SupabaseClient<Database>,\n  params: BookEventParams\n): Promise<BookEventResult> {\n  const { eventId } = params;\n\n  const { data, error } = await client.rpc('book_event', {\n    p_event_id: eventId,\n  });\n\n  if (error) {\n    handleRpcError(error, 'book_event');\n  }\n\n  return data as BookEventResult;\n}\n\n/**\n * Wrapper tipizzato per la RPC cancel_event_booking.\n * Cancella una prenotazione evento usando l'ID della prenotazione.\n * \n * @param client - Il client Supabase autenticato\n * @param params - Parametri per la cancellazione\n * @returns Promise<CancelEventBookingResult> con ok e reason opzionale\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function cancelEventBooking(\n  client: SupabaseClient<Database>,\n  params: CancelEventBookingParams\n): Promise<CancelEventBookingResult> {\n  const { bookingId } = params;\n\n  if (!bookingId || typeof bookingId !== 'string') {\n    throw new Error('cancelEventBooking: bookingId must be a non-empty string');\n  }\n\n  const { data, error } = await client.rpc('cancel_event_booking', {\n    p_booking_id: bookingId,\n  } as Database['public']['Functions']['cancel_event_booking']['Args']);\n\n  if (error) {\n    handleRpcError(error, 'cancel_event_booking');\n  }\n\n  return data as CancelEventBookingResult;\n}\n\n/**\n * Wrapper tipizzato per la RPC staff_book_event.\n * Prenota un evento per un cliente (staff only).\n * \n * @param client - Il client Supabase autenticato (deve essere staff)\n * @param params - Parametri per la prenotazione\n * @returns Promise<BookEventResult> con ok, reason opzionale, e booking_id se successo\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function staffBookEvent(\n  client: SupabaseClient<Database>,\n  params: StaffBookEventParams\n): Promise<BookEventResult> {\n  const { eventId, clientId } = params;\n\n  const { data, error } = await client.rpc('staff_book_event', {\n    p_event_id: eventId,\n    p_client_id: clientId,\n  });\n\n  if (error) {\n    handleRpcError(error, 'staff_book_event');\n  }\n\n  return data as BookEventResult;\n}\n\n/**\n * Wrapper tipizzato per la RPC staff_cancel_event_booking.\n * Cancella una prenotazione evento (staff only).\n * \n * @param client - Il client Supabase autenticato (deve essere staff)\n * @param params - Parametri per la cancellazione\n * @returns Promise<CancelEventBookingResult> con ok e reason opzionale\n * @throws Error se la chiamata RPC fallisce\n */\nexport async function staffCancelEventBooking(\n  client: SupabaseClient<Database>,\n  params: StaffCancelEventBookingParams\n): Promise<CancelEventBookingResult> {\n  const { bookingId } = params;\n\n  if (!bookingId || typeof bookingId !== 'string') {\n    throw new Error('staffCancelEventBooking: bookingId must be a non-empty string');\n  }\n\n  const { data, error } = await client.rpc('staff_cancel_event_booking', {\n    p_booking_id: bookingId,\n  } as Database['public']['Functions']['staff_cancel_event_booking']['Args']);\n\n  if (error) {\n    handleRpcError(error, 'staff_cancel_event_booking');\n  }\n\n  return data as CancelEventBookingResult;\n}\n\n","import type { SupabaseClient } from '@supabase/supabase-js';\nimport type { Database } from '../types/database';\n\n/**\n * Tipo per i nomi delle views pubbliche del sito.\n * Le views devono iniziare con \"public_site_\" per essere considerate pubbliche.\n */\nexport type PublicViewName = `public_site_${string}`;\n\n/**\n * Helper per accedere alle views pubbliche in modo type-safe.\n * Questo impedisce l'uso accidentale di tabelle non pubbliche.\n * \n * NOTA: Le views pubbliche (public_site_*) devono essere create nel database e i types\n * devono essere rigenerati prima di usare questa funzione.\n * \n * @param client - Il client Supabase (può essere anonimo per views pubbliche)\n * @param view - Il nome della view pubblica (deve iniziare con \"public_site_\")\n * @returns Il query builder per la view specificata\n */\nexport function fromPublic<T extends PublicViewName>(\n  client: SupabaseClient<Database>,\n  view: T\n) {\n  // @ts-expect-error - Le views public_site_* non sono ancora presenti nel database types\n  // Verrà risolto quando le views verranno create e i types rigenerati\n  return client.from(view);\n}\n \n/**\n * Parametri opzionali per filtrare lo schedule pubblico per date\n */\nexport type GetPublicScheduleParams = {\n  from?: string;\n  to?: string;\n};\n\n/**\n * Recupera lo schedule pubblico dal database.\n * Questa funzione accede alla view public_site_schedule e applica filtri opzionali per date.\n * \n * NOTA: La view public_site_schedule deve essere creata nel database e i types devono essere rigenerati\n * prima di usare questa funzione.\n * \n * @param client - Il client Supabase (anonimo ok per views pubbliche)\n * @param params - Parametri opzionali per filtrare per date\n * @returns Promise con i dati dello schedule\n * @throws Error se la query fallisce\n */\nexport async function getPublicSchedule(\n  client: SupabaseClient<Database>,\n  params?: GetPublicScheduleParams\n) {\n  let query = fromPublic(client, 'public_site_schedule').select('*');\n\n  if (params?.from) {\n    query = query.gte('date', params.from);\n  }\n  if (params?.to) {\n    query = query.lte('date', params.to);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    throw new Error(`Failed to fetch public schedule: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Recupera i prezzi pubblici dal database.\n * Questa funzione accede alla view public_site_pricing.\n * \n * NOTA: La view public_site_pricing deve essere creata nel database e i types devono essere rigenerati\n * prima di usare questa funzione.\n * \n * @param client - Il client Supabase (anonimo ok per views pubbliche)\n * @returns Promise con i dati dei prezzi\n * @throws Error se la query fallisce\n */\nexport async function getPublicPricing(client: SupabaseClient<Database>) {\n  const { data, error } = await fromPublic(client, 'public_site_pricing')\n    .select('*');\n\n  if (error) {\n    throw new Error(`Failed to fetch public pricing: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Recupera le attività pubbliche dal database.\n * Questa funzione accede alla view public_site_activities.\n * \n * NOTA: La view public_site_activities deve essere creata nel database e i types devono essere rigenerati\n * prima di usare questa funzione.\n * \n * @param client - Il client Supabase (anonimo ok per views pubbliche)\n * @returns Promise con i dati delle attività\n * @throws Error se la query fallisce\n */\nexport async function getPublicActivities(client: SupabaseClient<Database>) {\n  const { data, error } = await fromPublic(client, 'public_site_activities')\n    .select('*');\n\n  if (error) {\n    throw new Error(`Failed to fetch public activities: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Recupera gli operatori attivi dal database.\n * Questa funzione accede alla view public_site_operators.\n * \n * NOTA: La view public_site_operators deve essere creata nel database e i types devono essere rigenerati\n * prima di usare questa funzione.\n * \n * @param client - Il client Supabase (anonimo ok per views pubbliche)\n * @returns Promise con i dati degli operatori\n * @throws Error se la query fallisce\n */\nexport async function getPublicOperators(client: SupabaseClient<Database>) {\n  const { data, error } = await fromPublic(client, 'public_site_operators')\n    .select('*');\n\n  if (error) {\n    throw new Error(`Failed to fetch public operators: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Parametri opzionali per filtrare gli eventi pubblici per date\n */\nexport type GetPublicEventsParams = {\n  from?: string;\n  to?: string;\n};\n\n/**\n * Recupera gli eventi pubblici dal database.\n * Questa funzione accede alla view public_site_events e applica filtri opzionali per date.\n * \n * NOTA: Ogni evento è un record separato con una singola data/orario (starts_at/ends_at).\n * Se un evento ha più date/orari, vengono creati record separati nel database.\n * Per raggruppare eventi con lo stesso nome, farlo lato client.\n * \n * @param client - Il client Supabase (anonimo ok per views pubbliche)\n * @param params - Parametri opzionali per filtrare per date\n * @returns Promise con i dati degli eventi (ogni evento ha una singola data/orario)\n * @throws Error se la query fallisce\n */\nexport async function getPublicEvents(\n  client: SupabaseClient<Database>,\n  params?: GetPublicEventsParams\n) {\n  let query = fromPublic(client, 'public_site_events').select('*');\n\n  // NOTA: La view public_site_events espone start_date (non starts_at)\n  if (params?.from) {\n    query = query.gte('start_date', params.from);\n  }\n  if (params?.to) {\n    query = query.lte('start_date', params.to);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    throw new Error(`Failed to fetch public events: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Tipo per evento con conteggio posti disponibili\n */\nexport type EventWithAvailability = {\n  id: string;\n  name: string;\n  description: string | null;\n  image_url: string | null;\n  link: string | null;\n  starts_at: string;\n  ends_at: string | null;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n  deleted_at: string | null;\n  capacity: number | null;\n  location: string | null;\n  price_cents: number | null;\n  currency: string | null;\n  booked_count: number;\n  available_spots: number | null; // null se capacity è null (illimitato)\n  is_full: boolean;\n};\n\n/**\n * Parametri opzionali per filtrare gli eventi con disponibilità\n */\nexport type GetEventsWithAvailabilityParams = {\n  from?: string;\n  to?: string;\n  onlyAvailable?: boolean; // Se true, mostra solo eventi con posti disponibili\n};\n\n/**\n * Recupera gli eventi con conteggio posti disponibili.\n * Questa funzione è utile per mostrare all'utente quanti posti sono ancora disponibili.\n * \n * @param client - Il client Supabase autenticato\n * @param params - Parametri opzionali per filtrare\n * @returns Promise con gli eventi arricchiti con disponibilità\n * @throws Error se la query fallisce\n */\nexport async function getEventsWithAvailability(\n  client: SupabaseClient<Database>,\n  params?: GetEventsWithAvailabilityParams\n): Promise<EventWithAvailability[]> {\n  // Query base per eventi attivi e non soft-deleted\n  let query = client\n    .from('events')\n    .select(`\n      id,\n      name,\n      description,\n      image_url,\n      link,\n      starts_at,\n      ends_at,\n      is_active,\n      created_at,\n      updated_at,\n      deleted_at,\n      capacity,\n      location,\n      price_cents,\n      currency\n    `)\n    .eq('is_active', true)\n    .is('deleted_at', null);\n\n  // Filtri per data\n  if (params?.from) {\n    query = query.gte('starts_at', params.from);\n  }\n  if (params?.to) {\n    query = query.lte('starts_at', params.to);\n  }\n\n  const { data: events, error: eventsError } = await query;\n\n  if (eventsError) {\n    throw new Error(`Failed to fetch events: ${eventsError.message}`);\n  }\n\n  if (!events || events.length === 0) {\n    return [];\n  }\n\n  // Recupera conteggio prenotazioni per ogni evento\n  const eventIds = events.map((e) => e.id);\n\n  const { data: bookingsCount, error: bookingsError } = await client\n    .from('event_bookings')\n    .select('event_id')\n    .in('event_id', eventIds)\n    .in('status', ['booked', 'attended', 'no_show']);\n\n  if (bookingsError) {\n    throw new Error(`Failed to fetch bookings count: ${bookingsError.message}`);\n  }\n\n  // Calcola conteggio per evento\n  const bookingsCountMap = new Map<string, number>();\n  if (bookingsCount) {\n    for (const booking of bookingsCount) {\n      const count = bookingsCountMap.get(booking.event_id) || 0;\n      bookingsCountMap.set(booking.event_id, count + 1);\n    }\n  }\n\n  // Costruisci risultato con disponibilità\n  const result: EventWithAvailability[] = events\n    .map((event) => {\n      const bookedCount = bookingsCountMap.get(event.id) || 0;\n      const availableSpots =\n        event.capacity !== null ? Math.max(0, event.capacity - bookedCount) : null;\n      const isFull = event.capacity !== null && availableSpots === 0;\n\n      return {\n        ...event,\n        booked_count: bookedCount,\n        available_spots: availableSpots,\n        is_full: isFull,\n      };\n    })\n    .filter((event) => {\n      // Filtra solo disponibili se richiesto\n      if (params?.onlyAvailable) {\n        return !event.is_full;\n      }\n      return true;\n    });\n\n  return result;\n}\n\n"]}